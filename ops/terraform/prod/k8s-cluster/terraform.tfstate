{
  "version": 4,
  "terraform_version": "1.3.6",
  "serial": 10,
  "lineage": "cc29db46-ba7e-d15a-ab0c-facd08d21b53",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "helm_release",
      "name": "ingress_nginx_release",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "atomic": false,
            "chart": "../../../charts/ingress-nginx/chart",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "ingress-nginx",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "1.2.1",
                "chart": "ingress-nginx",
                "name": "ingress-nginx",
                "namespace": "ingress-nginx",
                "revision": 1,
                "values": "null",
                "version": "4.1.3"
              }
            ],
            "name": "ingress-nginx",
            "namespace": "ingress-nginx",
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": null,
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              ""
            ],
            "verify": false,
            "version": "4.1.3",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "kubernetes_namespace.ingress_nginx_namespace"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "helm_release",
      "name": "istio_base_release",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "atomic": false,
            "chart": "../../../charts/istio-base",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "istio-base",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "1.16.1",
                "chart": "base",
                "name": "istio-base",
                "namespace": "istio-system",
                "revision": 1,
                "values": "{\"base\":{\"enableCRDTemplates\":false,\"enableIstioConfigCRDs\":true,\"validationURL\":\"\"},\"defaultRevision\":\"default\",\"global\":{\"configValidation\":true,\"externalIstiod\":false,\"imagePullSecrets\":[],\"istioNamespace\":\"istio-system\",\"istiod\":{\"enableAnalysis\":false},\"remotePilotAddress\":\"\"}}",
                "version": "1.16.1"
              }
            ],
            "name": "istio-base",
            "namespace": "istio-system",
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": null,
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "global:\n\n  # ImagePullSecrets for control plane ServiceAccount, list of secrets in the same namespace\n  # to use for pulling any images in pods that reference this ServiceAccount.\n  # Must be set for any cluster configured with private docker registry.\n  imagePullSecrets: []\n\n  # Used to locate istiod.\n  istioNamespace: istio-system\n\n  istiod:\n    enableAnalysis: false\n\n  configValidation: true\n  externalIstiod: false\n  remotePilotAddress: \"\"\n\nbase:\n  # Used for helm2 to add the CRDs to templates.\n  enableCRDTemplates: false\n\n  # Validation webhook configuration url\n  # For example: https://$remotePilotAddress:15017/validate\n  validationURL: \"\"\n\n  # For istioctl usage to disable istio config crds in base\n  enableIstioConfigCRDs: true\n\ndefaultRevision: \"default\"\n"
            ],
            "verify": false,
            "version": "1.16.1",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "kubernetes_namespace.istio_system_namespace"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "helm_release",
      "name": "istiod_release",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "atomic": false,
            "chart": "../../../charts/istiod",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "istiod",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "1.16.1",
                "chart": "istiod",
                "name": "istiod",
                "namespace": "istio-system",
                "revision": 1,
                "values": "{\"base\":{\"enableIstioConfigCRDs\":true},\"global\":{\"autoscalingv2API\":true,\"caAddress\":\"\",\"caName\":\"\",\"configCluster\":false,\"defaultPodDisruptionBudget\":{\"enabled\":true},\"defaultResources\":{\"requests\":{\"cpu\":\"10m\"}},\"externalIstiod\":false,\"hub\":\"docker.io/istio\",\"imagePullPolicy\":\"\",\"imagePullSecrets\":[],\"istioNamespace\":\"istio-system\",\"istiod\":{\"enableAnalysis\":false},\"jwtPolicy\":\"third-party-jwt\",\"logAsJson\":false,\"logging\":{\"level\":\"default:info\"},\"meshID\":\"\",\"meshNetworks\":{},\"mountMtlsCerts\":false,\"multiCluster\":{\"clusterName\":\"\",\"enabled\":false},\"network\":\"\",\"omitSidecarInjectorConfigMap\":false,\"oneNamespace\":false,\"operatorManageWebhooks\":false,\"pilotCertProvider\":\"istiod\",\"priorityClassName\":\"\",\"proxy\":{\"autoInject\":\"enabled\",\"clusterDomain\":\"cluster.local\",\"componentLogLevel\":\"misc:error\",\"enableCoreDump\":false,\"excludeIPRanges\":\"\",\"excludeInboundPorts\":\"\",\"excludeOutboundPorts\":\"\",\"holdApplicationUntilProxyStarts\":false,\"image\":\"proxyv2\",\"includeIPRanges\":\"*\",\"includeInboundPorts\":\"*\",\"includeOutboundPorts\":\"\",\"logLevel\":\"warning\",\"privileged\":false,\"readinessFailureThreshold\":30,\"readinessInitialDelaySeconds\":1,\"readinessPeriodSeconds\":2,\"resources\":{\"limits\":{\"cpu\":\"2000m\",\"memory\":\"1024Mi\"},\"requests\":{\"cpu\":\"100m\",\"memory\":\"128Mi\"}},\"statusPort\":15020,\"tracer\":\"zipkin\"},\"proxy_init\":{\"image\":\"proxyv2\"},\"remotePilotAddress\":\"\",\"sds\":{\"token\":{\"aud\":\"istio-ca\"}},\"sts\":{\"servicePort\":0},\"tag\":\"1.16.1\",\"tracer\":{\"datadog\":{\"address\":\"$(HOST_IP):8126\"},\"lightstep\":{\"accessToken\":\"\",\"address\":\"\"},\"stackdriver\":{\"debug\":false,\"maxNumberOfAnnotations\":200,\"maxNumberOfAttributes\":200,\"maxNumberOfMessageEvents\":200},\"zipkin\":{\"address\":\"\"}},\"useMCP\":false,\"variant\":\"\"},\"istiodRemote\":{\"injectionPath\":\"/inject\",\"injectionURL\":\"\"},\"meshConfig\":{\"enablePrometheusMerge\":true,\"rootNamespace\":null,\"trustDomain\":\"cluster.local\"},\"ownerName\":\"\",\"pilot\":{\"autoscaleEnabled\":true,\"autoscaleMax\":5,\"autoscaleMin\":1,\"configMap\":true,\"configSource\":{\"subscribedResources\":[]},\"cpu\":{\"targetAverageUtilization\":80},\"deploymentLabels\":{},\"enableProtocolSniffingForInbound\":true,\"enableProtocolSniffingForOutbound\":true,\"env\":{},\"hub\":\"\",\"image\":\"pilot\",\"jwksResolverExtraRootCA\":\"\",\"keepaliveMaxServerConnectionAge\":\"30m\",\"nodeSelector\":{},\"plugins\":[],\"podAnnotations\":{},\"podLabels\":{},\"replicaCount\":1,\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"2048Mi\"}},\"rollingMaxSurge\":\"100%\",\"rollingMaxUnavailable\":\"25%\",\"seccompProfile\":{},\"serviceAnnotations\":{},\"tag\":\"\",\"traceSampling\":1,\"variant\":\"\"},\"revision\":\"\",\"revisionTags\":[],\"sidecarInjectorWebhook\":{\"alwaysInjectSelector\":[],\"defaultTemplates\":[],\"enableNamespacesByDefault\":false,\"injectedAnnotations\":{},\"neverInjectSelector\":[],\"rewriteAppHTTPProbe\":true,\"templates\":{}},\"telemetry\":{\"enabled\":true,\"v2\":{\"accessLogPolicy\":{\"enabled\":false,\"logWindowDuration\":\"43200s\"},\"enabled\":true,\"metadataExchange\":{\"wasmEnabled\":false},\"prometheus\":{\"configOverride\":{\"gateway\":{},\"inboundSidecar\":{},\"outboundSidecar\":{}},\"enabled\":true,\"wasmEnabled\":false},\"stackdriver\":{\"configOverride\":{},\"disableOutbound\":false,\"enabled\":false,\"logging\":false,\"monitoring\":false,\"topology\":false}}}}",
                "version": "1.16.1"
              }
            ],
            "name": "istiod",
            "namespace": "istio-system",
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": null,
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "#.Values.pilot for discovery and mesh wide config\n\n## Discovery Settings\npilot:\n  autoscaleEnabled: true\n  autoscaleMin: 1\n  autoscaleMax: 5\n  replicaCount: 1\n  rollingMaxSurge: 100%\n  rollingMaxUnavailable: 25%\n\n  hub: \"\"\n  tag: \"\"\n  variant: \"\"\n\n  # Can be a full hub/image:tag\n  image: pilot\n  traceSampling: 1.0\n\n  # Resources for a small pilot install\n  resources:\n    requests:\n      cpu: 500m\n      memory: 2048Mi\n\n  # Set to `type: RuntimeDefault` to use the default profile if available.\n  seccompProfile: {}\n\n  env: {}\n\n  cpu:\n    targetAverageUtilization: 80\n\n  # if protocol sniffing is enabled for outbound\n  enableProtocolSniffingForOutbound: true\n  # if protocol sniffing is enabled for inbound\n  enableProtocolSniffingForInbound: true\n\n  nodeSelector: {}\n  podAnnotations: {}\n  serviceAnnotations: {}\n\n  # You can use jwksResolverExtraRootCA to provide a root certificate\n  # in PEM format. This will then be trusted by pilot when resolving\n  # JWKS URIs.\n  jwksResolverExtraRootCA: \"\"\n\n  # This is used to set the source of configuration for\n  # the associated address in configSource, if nothing is specified\n  # the default MCP is assumed.\n  configSource:\n    subscribedResources: []\n\n  plugins: []\n\n  # The following is used to limit how long a sidecar can be connected\n  # to a pilot. It balances out load across pilot instances at the cost of\n  # increasing system churn.\n  keepaliveMaxServerConnectionAge: 30m\n\n  # Additional labels to apply to the deployment.\n  deploymentLabels: {}\n\n  ## Mesh config settings\n\n  # Install the mesh config map, generated from values.yaml.\n  # If false, pilot wil use default values (by default) or user-supplied values.\n  configMap: true\n\n  # Additional labels to apply on the pod level for monitoring and logging configuration.\n  podLabels: {}\n\nsidecarInjectorWebhook:\n  # You can use the field called alwaysInjectSelector and neverInjectSelector which will always inject the sidecar or\n  # always skip the injection on pods that match that label selector, regardless of the global policy.\n  # See https://istio.io/docs/setup/kubernetes/additional-setup/sidecar-injection/#more-control-adding-exceptions\n  neverInjectSelector: []\n  alwaysInjectSelector: []\n\n  # injectedAnnotations are additional annotations that will be added to the pod spec after injection\n  # This is primarily to support PSP annotations. For example, if you defined a PSP with the annotations:\n  #\n  # annotations:\n  #   apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default\n  #   apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default\n  #\n  # The PSP controller would add corresponding annotations to the pod spec for each container. However, this happens before\n  # the inject adds additional containers, so we must specify them explicitly here. With the above example, we could specify:\n  # injectedAnnotations:\n  #   container.apparmor.security.beta.kubernetes.io/istio-init: runtime/default\n  #   container.apparmor.security.beta.kubernetes.io/istio-proxy: runtime/default\n  injectedAnnotations: {}\n\n  # This enables injection of sidecar in all namespaces,\n  # with the exception of namespaces with \"istio-injection:disabled\" annotation\n  # Only one environment should have this enabled.\n  enableNamespacesByDefault: false\n\n  rewriteAppHTTPProbe: true\n\n  # Templates defines a set of custom injection templates that can be used. For example, defining:\n  #\n  # templates:\n  #   hello: |\n  #     metadata:\n  #       labels:\n  #         hello: world\n  #\n  # Then starting a pod with the `inject.istio.io/templates: hello` annotation, will result in the pod\n  # being injected with the hello=world labels.\n  # This is intended for advanced configuration only; most users should use the built in template\n  templates: {}\n\n  # Default templates specifies a set of default templates that are used in sidecar injection.\n  # By default, a template `sidecar` is always provided, which contains the template of default sidecar.\n  # To inject other additional templates, define it using the `templates` option, and add it to\n  # the default templates list.\n  # For example:\n  #\n  # templates:\n  #   hello: |\n  #     metadata:\n  #       labels:\n  #         hello: world\n  #\n  # defaultTemplates: [\"sidecar\", \"hello\"]\n  defaultTemplates: []\nistiodRemote:\n  # Sidecar injector mutating webhook configuration clientConfig.url value.\n  # For example: https://$remotePilotAddress:15017/inject\n  # The host should not refer to a service running in the cluster; use a service reference by specifying\n  # the clientConfig.service field instead.\n  injectionURL: \"\"\n\n  # Sidecar injector mutating webhook configuration path value for the clientConfig.service field.\n  # Override to pass env variables, for example: /inject/cluster/remote/net/network2\n  injectionPath: \"/inject\"\ntelemetry:\n  enabled: true\n  v2:\n    # For Null VM case now.\n    # This also enables metadata exchange.\n    enabled: true\n    metadataExchange:\n      # Indicates whether to enable WebAssembly runtime for metadata exchange filter.\n      wasmEnabled: false\n    # Indicate if prometheus stats filter is enabled or not\n    prometheus:\n      enabled: true\n      # Indicates whether to enable WebAssembly runtime for stats filter.\n      wasmEnabled: false\n      # overrides stats EnvoyFilter configuration.\n      configOverride:\n        gateway: {}\n        inboundSidecar: {}\n        outboundSidecar: {}\n    # stackdriver filter settings.\n    stackdriver:\n      enabled: false\n      logging: false\n      monitoring: false\n      topology: false # deprecated. setting this to true will have no effect, as this option is no longer supported.\n      disableOutbound: false\n      #  configOverride parts give you the ability to override the low level configuration params passed to envoy filter.\n\n      configOverride: {}\n      #  e.g.\n      #  disable_server_access_logging: false\n      #  disable_host_header_fallback: true\n    # Access Log Policy Filter Settings. This enables filtering of access logs from stackdriver.\n    accessLogPolicy:\n      enabled: false\n      # To reduce the number of successful logs, default log window duration is\n      # set to 12 hours.\n      logWindowDuration: \"43200s\"\n# Revision is set as 'version' label and part of the resource names when installing multiple control planes.\nrevision: \"\"\n\n# Revision tags are aliases to Istio control plane revisions\nrevisionTags: []\n\n# For Helm compatibility.\nownerName: \"\"\n\n# meshConfig defines runtime configuration of components, including Istiod and istio-agent behavior\n# See https://istio.io/docs/reference/config/istio.mesh.v1alpha1/ for all available options\nmeshConfig:\n  enablePrometheusMerge: true\n  # Config for the default ProxyConfig.\n  # Initially using directly the proxy metadata - can also be activated using annotations\n  # on the pod. This is an unsupported low-level API, pending review and decisions on\n  # enabling the feature. Enabling the DNS listener is safe - and allows further testing\n  # and gradual adoption by setting capture only on specific workloads. It also allows\n  # VMs to use other DNS options, like dnsmasq or unbound.\n\n  # The namespace to treat as the administrative root namespace for Istio configuration.\n  # When processing a leaf namespace Istio will search for declarations in that namespace first\n  # and if none are found it will search in the root namespace. Any matching declaration found in the root namespace\n  # is processed as if it were declared in the leaf namespace.\n\n  rootNamespace:\n\n  # The trust domain corresponds to the trust root of a system\n  # Refer to https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain\n  trustDomain: \"cluster.local\"\n\n  # TODO: the intent is to eventually have this enabled by default when security is used.\n  # It is not clear if user should normally need to configure - the metadata is typically\n  # used as an escape and to control testing and rollout, but it is not intended as a long-term\n  # stable API.\n\n  # What we may configure in mesh config is the \".global\" - and use of other suffixes.\n  # No hurry to do this in 1.6, we're trying to prove the code.\n\nglobal:\n  # Used to locate istiod.\n  istioNamespace: istio-system\n  # enable pod disruption budget for the control plane, which is used to\n  # ensure Istio control plane components are gradually upgraded or recovered.\n  defaultPodDisruptionBudget:\n    enabled: true\n    # The values aren't mutable due to a current PodDisruptionBudget limitation\n    # minAvailable: 1\n\n  # A minimal set of requested resources to applied to all deployments so that\n  # Horizontal Pod Autoscaler will be able to function (if set).\n  # Each component can overwrite these default values by adding its own resources\n  # block in the relevant section below and setting the desired resources values.\n  defaultResources:\n    requests:\n      cpu: 10m\n    #   memory: 128Mi\n    # limits:\n    #   cpu: 100m\n    #   memory: 128Mi\n\n  # Default hub for Istio images.\n  # Releases are published to docker hub under 'istio' project.\n  # Dev builds from prow are on gcr.io\n  hub: docker.io/istio\n  # Default tag for Istio images.\n  tag: 1.16.1\n  # Variant of the image to use.\n  # Currently supported are: [debug, distroless]\n  variant: \"\"\n\n  # Specify image pull policy if default behavior isn't desired.\n  # Default behavior: latest images will be Always else IfNotPresent.\n  imagePullPolicy: \"\"\n\n  # ImagePullSecrets for all ServiceAccount, list of secrets in the same namespace\n  # to use for pulling any images in pods that reference this ServiceAccount.\n  # For components that don't use ServiceAccounts (i.e. grafana, servicegraph, tracing)\n  # ImagePullSecrets will be added to the corresponding Deployment(StatefulSet) objects.\n  # Must be set for any cluster configured with private docker registry.\n  imagePullSecrets: []\n  # - private-registry-key\n\n  # Enabled by default in master for maximising testing.\n  istiod:\n    enableAnalysis: false\n\n  # To output all istio components logs in json format by adding --log_as_json argument to each container argument\n  logAsJson: false\n\n  # Comma-separated minimum per-scope logging level of messages to output, in the form of \u003cscope\u003e:\u003clevel\u003e,\u003cscope\u003e:\u003clevel\u003e\n  # The control plane has different scopes depending on component, but can configure default log level across all components\n  # If empty, default scope and level will be used as configured in code\n  logging:\n    level: \"default:info\"\n\n  omitSidecarInjectorConfigMap: false\n\n  # Whether to restrict the applications namespace the controller manages;\n  # If not set, controller watches all namespaces\n  oneNamespace: false\n\n  # Configure whether Operator manages webhook configurations. The current behavior\n  # of Istiod is to manage its own webhook configurations.\n  # When this option is set as true, Istio Operator, instead of webhooks, manages the\n  # webhook configurations. When this option is set as false, webhooks manage their\n  # own webhook configurations.\n  operatorManageWebhooks: false\n\n  # Custom DNS config for the pod to resolve names of services in other\n  # clusters. Use this to add additional search domains, and other settings.\n  # see\n  # https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#dns-config\n  # This does not apply to gateway pods as they typically need a different\n  # set of DNS settings than the normal application pods (e.g., in\n  # multicluster scenarios).\n  # NOTE: If using templates, follow the pattern in the commented example below.\n  #podDNSSearchNamespaces:\n  #- global\n  #- \"{{ valueOrDefault .DeploymentMeta.Namespace \\\"default\\\" }}.global\"\n\n  # Kubernetes \u003e=v1.11.0 will create two PriorityClass, including system-cluster-critical and\n  # system-node-critical, it is better to configure this in order to make sure your Istio pods\n  # will not be killed because of low priority class.\n  # Refer to https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass\n  # for more detail.\n  priorityClassName: \"\"\n\n  proxy:\n    image: proxyv2\n\n    # This controls the 'policy' in the sidecar injector.\n    autoInject: enabled\n\n    # CAUTION: It is important to ensure that all Istio helm charts specify the same clusterDomain value\n    # cluster domain. Default value is \"cluster.local\".\n    clusterDomain: \"cluster.local\"\n\n    # Per Component log level for proxy, applies to gateways and sidecars. If a component level is\n    # not set, then the global \"logLevel\" will be used.\n    componentLogLevel: \"misc:error\"\n\n    # If set, newly injected sidecars will have core dumps enabled.\n    enableCoreDump: false\n\n    # istio ingress capture allowlist\n    # examples:\n    #     Redirect only selected ports:            --includeInboundPorts=\"80,8080\"\n    excludeInboundPorts: \"\"\n    includeInboundPorts: \"*\"\n\n    # istio egress capture allowlist\n    # https://istio.io/docs/tasks/traffic-management/egress.html#calling-external-services-directly\n    # example: includeIPRanges: \"172.30.0.0/16,172.20.0.0/16\"\n    # would only capture egress traffic on those two IP Ranges, all other outbound traffic would\n    # be allowed by the sidecar\n    includeIPRanges: \"*\"\n    excludeIPRanges: \"\"\n    includeOutboundPorts: \"\"\n    excludeOutboundPorts: \"\"\n\n    # Log level for proxy, applies to gateways and sidecars.\n    # Expected values are: trace|debug|info|warning|error|critical|off\n    logLevel: warning\n\n    #If set to true, istio-proxy container will have privileged securityContext\n    privileged: false\n\n    # The number of successive failed probes before indicating readiness failure.\n    readinessFailureThreshold: 30\n\n    # The initial delay for readiness probes in seconds.\n    readinessInitialDelaySeconds: 1\n\n    # The period between readiness probes.\n    readinessPeriodSeconds: 2\n\n    # Resources for the sidecar.\n    resources:\n      requests:\n        cpu: 100m\n        memory: 128Mi\n      limits:\n        cpu: 2000m\n        memory: 1024Mi\n\n    # Default port for Pilot agent health checks. A value of 0 will disable health checking.\n    statusPort: 15020\n\n    # Specify which tracer to use. One of: zipkin, lightstep, datadog, stackdriver.\n    # If using stackdriver tracer outside GCP, set env GOOGLE_APPLICATION_CREDENTIALS to the GCP credential file.\n    tracer: \"zipkin\"\n\n    # Controls if sidecar is injected at the front of the container list and blocks the start of the other containers until the proxy is ready\n    holdApplicationUntilProxyStarts: false\n\n  proxy_init:\n    # Base name for the proxy_init container, used to configure iptables.\n    image: proxyv2\n\n  # configure remote pilot and istiod service and endpoint\n  remotePilotAddress: \"\"\n\n  ##############################################################################################\n  # The following values are found in other charts. To effectively modify these values, make   #\n  # make sure they are consistent across your Istio helm charts                                #\n  ##############################################################################################\n\n  # The customized CA address to retrieve certificates for the pods in the cluster.\n  # CSR clients such as the Istio Agent and ingress gateways can use this to specify the CA endpoint.\n  # If not set explicitly, default to the Istio discovery address.\n  caAddress: \"\"\n\n  # Configure a remote cluster data plane controlled by an external istiod.\n  # When set to true, istiod is not deployed locally and only a subset of the other\n  # discovery charts are enabled.\n  externalIstiod: false\n\n  # Configure a remote cluster as the config cluster for an external istiod.\n  configCluster: false\n\n  # Configure the policy for validating JWT.\n  # Currently, two options are supported: \"third-party-jwt\" and \"first-party-jwt\".\n  jwtPolicy: \"third-party-jwt\"\n\n  # Mesh ID means Mesh Identifier. It should be unique within the scope where\n  # meshes will interact with each other, but it is not required to be\n  # globally/universally unique. For example, if any of the following are true,\n  # then two meshes must have different Mesh IDs:\n  # - Meshes will have their telemetry aggregated in one place\n  # - Meshes will be federated together\n  # - Policy will be written referencing one mesh from the other\n  #\n  # If an administrator expects that any of these conditions may become true in\n  # the future, they should ensure their meshes have different Mesh IDs\n  # assigned.\n  #\n  # Within a multicluster mesh, each cluster must be (manually or auto)\n  # configured to have the same Mesh ID value. If an existing cluster 'joins' a\n  # multicluster mesh, it will need to be migrated to the new mesh ID. Details\n  # of migration TBD, and it may be a disruptive operation to change the Mesh\n  # ID post-install.\n  #\n  # If the mesh admin does not specify a value, Istio will use the value of the\n  # mesh's Trust Domain. The best practice is to select a proper Trust Domain\n  # value.\n  meshID: \"\"\n\n  # Configure the mesh networks to be used by the Split Horizon EDS.\n  #\n  # The following example defines two networks with different endpoints association methods.\n  # For `network1` all endpoints that their IP belongs to the provided CIDR range will be\n  # mapped to network1. The gateway for this network example is specified by its public IP\n  # address and port.\n  # The second network, `network2`, in this example is defined differently with all endpoints\n  # retrieved through the specified Multi-Cluster registry being mapped to network2. The\n  # gateway is also defined differently with the name of the gateway service on the remote\n  # cluster. The public IP for the gateway will be determined from that remote service (only\n  # LoadBalancer gateway service type is currently supported, for a NodePort type gateway service,\n  # it still need to be configured manually).\n  #\n  # meshNetworks:\n  #   network1:\n  #     endpoints:\n  #     - fromCidr: \"192.168.0.1/24\"\n  #     gateways:\n  #     - address: 1.1.1.1\n  #       port: 80\n  #   network2:\n  #     endpoints:\n  #     - fromRegistry: reg1\n  #     gateways:\n  #     - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local\n  #       port: 443\n  #\n  meshNetworks: {}\n\n  # Use the user-specified, secret volume mounted key and certs for Pilot and workloads.\n  mountMtlsCerts: false\n\n  multiCluster:\n    # Set to true to connect two kubernetes clusters via their respective\n    # ingressgateway services when pods in each cluster cannot directly\n    # talk to one another. All clusters should be using Istio mTLS and must\n    # have a shared root CA for this model to work.\n    enabled: false\n    # Should be set to the name of the cluster this installation will run in. This is required for sidecar injection\n    # to properly label proxies\n    clusterName: \"\"\n\n  # Network defines the network this cluster belong to. This name\n  # corresponds to the networks in the map of mesh networks.\n  network: \"\"\n\n  # Configure the certificate provider for control plane communication.\n  # Currently, two providers are supported: \"kubernetes\" and \"istiod\".\n  # As some platforms may not have kubernetes signing APIs,\n  # Istiod is the default\n  pilotCertProvider: istiod\n\n  sds:\n    # The JWT token for SDS and the aud field of such JWT. See RFC 7519, section 4.1.3.\n    # When a CSR is sent from Istio Agent to the CA (e.g. Istiod), this aud is to make sure the\n    # JWT is intended for the CA.\n    token:\n      aud: istio-ca\n\n  sts:\n    # The service port used by Security Token Service (STS) server to handle token exchange requests.\n    # Setting this port to a non-zero value enables STS server.\n    servicePort: 0\n\n  # Configuration for each of the supported tracers\n  tracer:\n    # Configuration for envoy to send trace data to LightStep.\n    # Disabled by default.\n    # address: the \u003chost\u003e:\u003cport\u003e of the satellite pool\n    # accessToken: required for sending data to the pool\n    #\n    datadog:\n      # Host:Port for submitting traces to the Datadog agent.\n      address: \"$(HOST_IP):8126\"\n    lightstep:\n      address: \"\" # example: lightstep-satellite:443\n      accessToken: \"\" # example: abcdefg1234567\n    stackdriver:\n      # enables trace output to stdout.\n      debug: false\n      # The global default max number of message events per span.\n      maxNumberOfMessageEvents: 200\n      # The global default max number of annotation events per span.\n      maxNumberOfAnnotations: 200\n      # The global default max number of attributes per span.\n      maxNumberOfAttributes: 200\n    zipkin:\n      # Host:Port for reporting trace data in zipkin format. If not specified, will default to\n      # zipkin service (port 9411) in the same namespace as the other istio components.\n      address: \"\"\n\n  # Use the Mesh Control Protocol (MCP) for configuring Istiod. Requires an MCP source.\n  useMCP: false\n\n  # The name of the CA for workload certificates.\n  # For example, when caName=GkeWorkloadCertificate, GKE workload certificates\n  # will be used as the certificates for workloads.\n  # The default value is \"\" and when caName=\"\", the CA will be configured by other\n  # mechanisms (e.g., environmental variable CA_PROVIDER).\n  caName: \"\"\n\n  # whether to use autoscaling/v2 template for HPA settings\n  # for internal usage only, not to be configured by users.\n  autoscalingv2API: true\n\nbase:\n  # For istioctl usage to disable istio config crds in base\n  enableIstioConfigCRDs: true\n"
            ],
            "verify": false,
            "version": "1.16.1",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "helm_release.istio_base_release",
            "kubernetes_namespace.istio_system_namespace"
          ]
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "ingress_nginx_namespace",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "ingress-nginx",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "ingress-nginx",
                "resource_version": "861",
                "uid": "48a743c2-4b1f-4b7a-9f8e-96cea5ceccd1"
              }
            ],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ=="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "inventory_namespace",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "inventory",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "inventory",
                "resource_version": "860",
                "uid": "6c7e6215-d69d-448a-9ba5-61e1938cb325"
              }
            ],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ=="
        }
      ]
    },
    {
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "istio_system_namespace",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "istio-system",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "istio-system",
                "resource_version": "1533",
                "uid": "8f55dcfc-c2b7-4949-9da0-0cd8ccb0fb91"
              }
            ],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ=="
        }
      ]
    }
  ],
  "check_results": null
}
